// Copyright 2016 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#pragma once

#include <deque>
#include <memory>

#include "apps/media/src/audio_server/audio_pipe.h"
#include "apps/media/src/audio_server/fwd_decls.h"
#include "apps/media/src/audio_server/gain.h"
#include "lib/ftl/synchronization/mutex.h"
#include "lib/ftl/synchronization/thread_annotations.h"

namespace media {
namespace audio {

// AudioRendererToOutputLink is a small class which renderers the relationship
// between an audio renderer and an audio output.  Renderers and outputs are
// expected to hold strong pointers to the state in the collections they use to
// renderer their peers.
//
// When either a renderer or an output ceases to exist, its collection will
// clear releasing the reference to the shared state.  When the other half of
// the relationship realizes that its peer has gone away (typically by failing
// to promote the weak reference to its peer held in the share state object), it
// can purge the state object strong pointer from its collection triggering the
// final cleanup of the shared state.
//
// Because the final cleanup of the shared state can be triggered either from an
// output manager mixer thread, or from the audio service's main message loop,
// it must be safe to destruct all of the shared state from any thread in the
// system.  No assumptions may be made about threading when destructing.
//
// The AudioRendererToOutputLink object holds a queue of pending audio packet
// references sourced from the AudioRenderer to be rendered on the audio output.
// The references are safe to release either from an output manager thread, or
// from the audio service's main message loop thread (which drives renderer
// behavior).
//
// Finally, both the Output may have a pointer to a Bookkeeping object in order
// to manage bookkeeping tasks specific to the Renderer/Output relationship. The
// following rules must be obeyed at all times...
//
// + Derrived classes of the Bookkeeping object created by the Output must be
//   safe to destroy either thread.  During destruction, no potentially blocking
//   operations may be performed.  No heavy operations (such as logging) should
//   be performed.
// + Only the output is permitted to access the output bookkeeping.  The
//   renderer must make no attempts to modify the bookkeeping or its pointer.
// + Outputs must hold a strong reference to the shared link object object
//   whenever they are accessing their bookkeeping object.  The link object is
//   considered to be the owner of the Bookkeeping, users must never hold a
//   naked pointer to their bookkeeping if the link could possibly destruct.
//
class AudioRendererToOutputLink {
 public:
  struct Bookkeeping {
    virtual ~Bookkeeping();
  };

  using BookkeepingPtr = std::unique_ptr<Bookkeeping>;
  using PacketQueue = std::deque<AudioPipe::AudioPacketRefPtr>;
  using PacketQueuePtr = std::unique_ptr<PacketQueue>;

  static AudioRendererToOutputLinkPtr New(AudioRendererImplWeakPtr renderer,
                                          AudioOutputWeakPtr output);
  virtual ~AudioRendererToOutputLink();

  // Utility function which recomputes the amplitude scale factor as function of
  // the renderer and the output gains.  Should only be called from the audio
  // service's main message loop thread.
  void UpdateGain();

  // Accessor for the current value of the gain's amplitude scalar.
  Gain::AScale amplitude_scale() const { return gain_.amplitude_scale(); }

  // Accessors for the renderer and output pointers.  Automatically attempts to
  // promote the weak pointer to a strong pointer.
  //
  // TODO(johngro):  Given the way outputs are currently shut down, there is
  // actually no need for the link to hold a weak pointer to output.  By the
  // time it destructs, All references to it are guaranteed to have been removed
  // from all renderers in the context of the main event loop.  Consider
  // converting this from a weak pointer to a strong pointer.
  AudioRendererImplPtr GetRenderer() { return renderer_.lock(); }
  AudioOutputPtr GetOutput() { return output_.lock(); }

  // AudioRenderer PendingQueue operations.  Never call these from the
  // AudioOutput.
  void PushToPendingQueue(const AudioPipe::AudioPacketRefPtr& pkt);
  void FlushPendingQueue();

  // AudioOutput PendingQueue operations.  Never call these from the
  // AudioRenderer.
  //
  // When consuming audio, AudioOutputs must always pair their calls to
  // LockPendingQueueFront and UnlockPendingQueueFront, passing the pointer to
  // the reference to the front of the queue they obtained in the process (even
  // if the front of the queue was nullptr).
  //
  // Doing so ensures that AudioRenderers which are attempting to flush the
  // pending queue are forced to wait if the front of the queue is involved in a
  // mixing operation.  This, in turn, guarantees that audio packets are always
  // returned to the user in the order which they were queued in without forcing
  // AudioRenderers to wait to queue new data if a mix operation is in progress.
  AudioPipe::AudioPacketRefPtr LockPendingQueueFront(bool* was_flushed)
      FTL_ACQUIRE(flush_mutex_);
  void UnlockPendingQueueFront(AudioPipe::AudioPacketRefPtr* pkt,
                               bool release_packet)
      FTL_THREAD_ANNOTATION_ATTRIBUTE__(release_capability(flush_mutex_));

  // Bookkeeping access.
  //
  BookkeepingPtr& output_bookkeeping() { return output_bookkeeping_; }

 private:
  void ReleaseQueue(const PacketQueuePtr& queue);

  AudioRendererToOutputLink(AudioRendererImplWeakPtr renderer,
                            AudioOutputWeakPtr output);

  AudioRendererImplWeakPtr renderer_;
  AudioOutputWeakPtr output_;
  BookkeepingPtr output_bookkeeping_;

  ftl::Mutex flush_mutex_;
  ftl::Mutex pending_queue_mutex_;
  PacketQueuePtr pending_queue_ FTL_GUARDED_BY(pending_queue_mutex_);
  bool flushed_ FTL_GUARDED_BY(flush_mutex_) = true;
  Gain gain_;
};

}  // namespace audio
}  // namespace media
